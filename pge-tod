#!/usr/bin/env python
"""
pge-tod by Preston Hunt <me@prestonhunt.com>

Compare time-of-day cost versus basic rate for Portland General Electric's Time
of Day program.
"""

import argparse
import csv
import sys

from datetime import datetime
from types import SimpleNamespace


# Rates as of 2024-02-05
BASIC_RATE = 19.45

OLD_TOD_RATES = {
    'off': 7.43,
    'mid': 11.9,
    'on': 32.8
}

NEW_TOD_RATES = {
    'off': 8.39,
    'mid': 15.77,
    'on': 41.11
}


def parse_args():
    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('csv_paths', nargs='*', help='csv files from portlandgeneral to process')
    return parser.parse_args()


def main():
    for path in ARGS.csv_paths:
        print(compare_tod_to_basic(path))


def skip_leader(path):
    skipping = True
    with open(path, newline='') as f:
        for line in f:
            if skipping and line.count(",") > 5:
                skipping = False
            if not skipping:
                yield line


def get_basic_cost(normrow) -> float:
    return round(BASIC_RATE * normrow.usage_kwh, 2)


def get_tod_category(d: datetime) -> str:
    # Off-peak on: 1/1, 7/4, 12/25 plus Mem Day, Lab Day, 1st Mon Sep, Thksgiving
    holidays = [(1,1), (7,4), (12,25)]
    if (d.month, d.day) in holidays:
        return 'off'
    if d.weekday() in [5, 6]:  # Sat or Sun
        return 'off'
    if d.hour < 7 or d.hour > 21:
        return 'off'
    if d.hour >= 7 and d.hour <= 17:
        return 'mid'
    return 'on'


def get_tod_rate(normrow) -> float:
    if normrow.starttime < datetime(2024, 1, 1):
        return OLD_TOD_RATES[normrow.tod_category]
    return NEW_TOD_RATES[normrow.tod_category]
#    raise Fail("did not find a TOD rate")


def normalize_row(row: dict) -> SimpleNamespace:
    # PGE has used multiple formats, including:
    #
    #    TYPE,DATE,START TIME,END TIME,USAGE,UNITS,DEMAND,UNITS,COST,NOTES
    #    Electric usage,2023-10-10,00:00,00:14,0.38,KWH,1.52,KW,$0.05
    #
    #    TYPE,DATE,START TIME,END TIME,USAGE (kWh),COST,NOTES
    #    Electric usage,2024-01-11,00:00,00:14,0.45,$0.03

    # Find out the field name for usage
    for field in row.keys():
        if 'usage' in field.lower():
            usage_field = field
            break
    else:
        raise Exception("unsupported or invalid CSV format, unable to find USAGE field")

    result = SimpleNamespace()
    result.starttime = datetime.strptime(row['DATE'] + ' ' + row['START TIME'], "%Y-%m-%d %H:%M")
    result.usage_kwh = float(row[usage_field])

    # As of 2024-02-05, the charged amount from PGE's CSV report is completely wrong.
    # Won't include it until it is more accurate
    # result.charged_cents = int(float(row['COST'].lstrip('$')) * 100)
    result.tod_category = get_tod_category(result.starttime)
    # kWh is provided with 2 significant digits; thus round the output to the same number of digits
    result.tod_rate = get_tod_rate(result)
    result.tod_cost_cents = round(result.tod_rate * result.usage_kwh, 2)
    result.basic_cost_cents = round(BASIC_RATE * result.usage_kwh, 2)
    return result


def compare_tod_to_basic(path) -> SimpleNamespace:
    print("processing", path)
    skip_iter = skip_leader(path)
    reader = csv.DictReader(skip_iter)
    tod_cost = 0.0
    basic_cost = 0.0
    earliest = None
    latest = None
    n = 0
    for row in reader:
        n += 1

        normrow = normalize_row(row)

        if earliest is None or normrow.starttime < earliest:
            earliest = normrow.starttime
        if latest is None or normrow.starttime > latest:
            latest = normrow.starttime

        tod_cost += normrow.tod_cost_cents
        basic_cost += normrow.basic_cost_cents
        print("\t", normrow)
    return SimpleNamespace(earliest=earliest,
                           latest=latest,
                           n=n,
                           tod_cost_usd=round(tod_cost / 100, 2),
                           basic_cost_usd=round(basic_cost / 100, 2))


class Fail(Exception):
    pass


if __name__ == '__main__':
    try:
        # Command-line arguments are considered as immutable constants of the
        # universe, and thus are globally available in this script.
        ARGS = parse_args()
        main()
    except Fail as f:
        print(*f.args, file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("Ctrl+C")
